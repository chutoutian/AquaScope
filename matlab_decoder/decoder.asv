Fs = 48000; % sampling frequency in Hz
BW = 20000;
SF = 7;
file_name_0 = 'raw_data/SF_7_BW_4_FC_4/Bob-Rx_Embedding-0.txt';
received_embedding_0 = load(file_name_0)';
file_name_1 = 'raw_data/SF_7_BW_4_FC_4/Bob-Rx_Embedding-1.txt';
received_embedding_1 = load(file_name_1)';
file_name_2 = 'raw_data/SF_7_BW_4_FC_4/Bob-Rx_Embedding-2.txt';
received_embedding_2 = load(file_name_2)';
file_name_3 = 'raw_data/SF_7_BW_4_FC_4/Bob-Rx_Embedding-3.txt';
received_embedding_3 = load(file_name_3)';
file_name_4 = 'raw_data/SF_7_BW_4_FC_4/Bob-Rx_Embedding-4.txt';
received_embedding_4 = load(file_name_4)';



raw_uncoded_bits = bitArray(1:7*12);
raw_bytes = [];
received_bits_cut = received_bits_0(1:7*12);
received_bytes = [];
for i = 1:12
    paddedBits = [raw_uncoded_bits((i-1) * 7 +1:i*7),0];
    raw_bytes = [raw_bytes; bi2de(paddedBits,'left-msb')];
    paddedBits = [received_bits_cut((i-1) * 7 +1:i*7),0];
    received_bytes = [received_bytes; bi2de(paddedBits,'left-msb')];
end
%}
% Sampling frequency and time vector


%transmitted_bytes = [24,32,0,0,91,45,94,13,1,74,34,82,18,23,19,114,5,13,4,99]';
gt_embedding = [125, 84, 548, 237, 608, 972, 875, 184, 577, 498, 887, 906, 172, 528, 539, 928, 508, 914, 382, 217, 730, 593, 589, 683, 533, 810, 821, 92, 171, 700, 982, 579, 788, 601, 589, 226, 624, 813, 903, 610, 937, 970, 109, 609, 539, 417, 308, 835, 761, 471, 358, 749, 469, 865, 1012, 150, 500, 805, 261, 40, 503, 548, 965, 713]';
gt_transmitted_bytes_before_encode = [31, 69, 72, -112, -19, -104, 60, -51, -84, -72, -112, 95, 45, -33, -118, 43, 33, 8, 111, -96, 127, 57, 37, -8, -39, -74, -91, 25, 54, -85, -123, 114, -84, -44, 92, 42, -21, -49, 90, 67, -59, 37, -103, 52, -30, -100, 50, -34, 30, 98, -22, 124, -95, -74, 97, -122, -38, 20, -45, 67, -66, 93, 117, -102, -19, 117, 118, 31, -48, -106, 125, 50, 84, 20, 40, 125, -30, 79, 22, -55]';
gt_transmitted_bytes_after_encode = [33,21,97,69,5,113,17,29,82,68,30,39,6,15,53,21,100,82,92,88,102,44,10,76,76,126,0,81,108,13,105,51,119,70,45,69,108,0,80,29,109,113,76,112,6,43,24,57,27,121,60,119,48,94,71,68,43,88,14,45,101,17,52,0,51,44,34,101,31,33,122,110,5,117,97,24,119,82,90,58,105,62,68,116,15,72,23,3,21,63,26,113,0,116,33,12,64,78,95,109,3,28,121,36,127,92,120,25,95,83,20,100,28,92,77,43,7,90,1,124,78,108,93,67,79,62,31,44,120,78,104,57,120,23,93,41,79,82,36,39,23,121,68,14,69,50,16,21,63,9,14,38,2,43,4,77,43,2,100,107,12,106,98,7,22,101,45,65,123,73,95,6,119,18,120,48,81,35,101,84,57,54,30,90,86,43,107,86,86,86,87,85]';

received_bytes_after_encode =       [32,20,96,68,4,112,16,28,81,67,29,38,5,14,52,20,99,81,91,87,101,43,9,75,75,125,127,80,107,12,104,50,118,69,44,68,107,127,79,28,108,112,75,111,5,42,23,56,26,120,59,118,47,93,70,67,42,87,13,44,100,16,51,127,50,43,33,100,30,32,121,109,4,116,96,23,118,81,89,57,104,61,67,115,14,71,22,2,20,62,25,112,127,115,32,11,63,77,94,108,2,27,120,37,126,91,119,24,94,82,19,99,27,91,76,42,6,89,0,123,77,107,92,66,78,61,30,43,119,77,103,56,119,24,94,42,80,83,37,40,24,122,69,15,70,51,17,22,64,10,15,39,3,44,5,78,44,3,101,108,13,107,99,8,23,102,46,66,124,74,96,7,120,19,121,49,82,36,102,85,58,55,31,91,87,44,108,87,87,87,88,86]';
received_bytes_before_encdoe = [31,69,72,-112,-19,-104,60,-51,-84,-72,-112,95,45,-33,-118,43,33,8,111,-96,127,57,37,-8,-39,-74,-91,25,54,-85,-123,114,-84,-44,92,42,-21,-49,90,67,-59,37,-103,52,-30,-100,50,-34,30,98,-22,124,-95,-74,97,-122,-38,20,-45,67,-66,93,117,-102,-19,117,118,31,-48,-106,125,50,84,20,40,125,-30,79,22,-55]';
received_embedding = [125,84,548,237,608,972,875,184,577,498,887,780,172,528,539,928,508,914,382,217,730,593,597,683,533,810,789,28,179,764,982,327,788,601,589,226,624,813,903,623,937,970,105,737,539,417,308,835,761,471,358,743,469,865,1012,150,500,805,261,40,503,548,965,705]';

diff_after_encode = gt_transmitted_bytes_after_encode - received_bytes_after_encode
indices = find(diff_after_encode ~= 0);
nnz(diff_after_encode)
diff_before_encode = gt_transmitted_bytes_before_encode - received_bytes_before_encdoe;
nnz(diff_before_encode)
diff_embedding = gt_embedding - received_embedding;
nnz(diff_embedding)

%received_symbol_0 = lowpass(received_symbol_0, 10000, 48000);
%received_symbol_1 = lowpass(received_symbol_1, 10000, 48000);
%received_symbol_2 = lowpass(received_symbol_2, 10000, 48000);
%received_symbol_3 = lowpass(received_symbol_3, 10000, 48000);
%received_symbol_4 = lowpass(received_symbol_4, 10000, 48000);

% remove the preamble 
start = (195 / 1000) * 48000;
start = start + 960;
raw_len = length(received_symbol_0);
for k = 0
    received_symbol_cut_preamble = received_symbol_0(start+1+k:raw_len);

    

    %%%%%%%% deinterleave
    received_realParts = received_symbol_cut_preamble(1:2:end) / 32767;
    received_imagParts = received_symbol_cut_preamble(2:2:end) / 32767;
    received_complex_symbol = received_realParts + 1i * received_imagParts;
    
    %%%%%%%% resample 
    received_symbol_sampled_bw = resample(received_complex_symbol, 20000,48000);
    received_symbol_sampled_2bw = resample(received_complex_symbol, 40000, 48000);
    
    
    uc = LoRaPHY.chirp(false, 7, 20000, 20000, 0, 0, 0);
    uc_1 = LoRaPHY.chirp(false, 7, 20000, 2* 20000, 0, 0, 0);
    dc = LoRaPHY.chirp(true, 7, 20000, 20000, 0, 0, 0);
    dc_1 = LoRaPHY.chirp(true, 7, 20000, 2* 20000, 0, 0, 0);
    
    ft_ori = [];
    product_ori = [];
    bin_index_ori = [];
    for i=1:16
        % Correct indexing and multiplication
        segment = received_symbol_sampled_bw((i-1) * 128 + 1 :i * 128);
        % Element-wise multiplication of the segment with uc_1
        if i == 3 || i == 4
            product = segment .* dc;
        else
            product = segment .* uc;
        end
        product_ori = [product_ori; product];
        % Calculate FFT and append to ft_ori
        fft_output = abs(fft(product, 128));
        [maxValue, maxIndex] = max(abs(fft_output));
        bin_index_ori = [bin_index_ori; maxIndex-1];
        ft_ori = [ft_ori;fft_output ];
    end
    bin_index_ori
    
    ft_double = [];
    product_double = [];
    bin_index_double = [];
    for i = 1:16
        segment = received_symbol_sampled_2bw((i-1) * 256 + 1:i * 256);
        % Element-wise multiplication of the segment with uc_1
        if i == 3 || i ==4
            product = segment .* dc_1;
        else
            product = segment .* uc_1;
        end
        product_double = [product_double; product];
        fft_output = fft(product, 2560);
        ft_ = abs(fft_output(1:1280)) + abs(fft_output(2560-1280+1:2560));
        ft_double = [ft_double;ft_];
        pk = LoRaPHY.topn([ft_ (1:1280).'], 1);
        index = mod((pk(2)+1280-1)/10, 2^7);
        bin_index_double = [bin_index_double; index];
    end
    
end

%for i=1:length(bin_index_double)
%    if bin_index_double(i) > 127
%        bin_index_double(i) = 2^7 - bin_index_double(i);
%    end
%end
bin_index_double
%for i = 1:18
    %xx = product_ori((i-1) * 128 + 1 :i * 128);
    %phaseDiff = angle(xx(2:end).* conj(xx(1:end-1)));
    %estimatedCFO = mean(diff(unwrap(phaseDiff))) / (2* pi) * BW
%estimatedCFO = (bin_index_double - transmitted_bytes(1:7)) * BW / 2^7
%end
%sfo_drift = ((1:length(bin_index_double))') * 2^7 * estimatedCFO(1) / 3750;
%symbols = mod(bin_index_double - sfo_drift, 2^7)
%{
for i =1:1
    phaseSignal = unwrap(angle(uc(1 + (i-1) *128:128 * i)));
    
    % Calculate time vector for sample points
    dt = 1/BW; % time increment
    timeVector = (0:length(received_symbol_sampled_bw(1 + (i-1) * 128:128 * i))-1) * dt;
    
    % Compute the derivative of the phase
    instantaneousFrequency = diff(phaseSignal) / (2*pi*dt);
    
    % Adjust time vector to match the frequency vector's length
    timeVector = timeVector(1:end-1);
    
    figure;
    plot(instantaneousFrequency);
    %plot(abs(fft(received_symbol_sampled_bw(1:128).*uc)));
    title('Instantaneous Frequency of the LoRa Symbol');
    xlabel('Index');
    ylabel('Magnitude');
    grid on;
end


for i =1:1
    figure;
    %plot(ft_double(1+(i-1)* 1280:1280*i));
    plot(ft_ori(1+(i-1)* 128:128*i));
    %plot(timeVector, instantaneousFrequency);
    title('Instantaneous Frequency of the LoRa Symbol');
    xlabel('Index');
    ylabel('Magnitude');
    grid on;
end

%}
